########################################################################################################################################################################
#
# HOW TO RUN SQL TUNING ADVISOR FOR A SQL_ID [AVAILABLE IN CURSOR]
#
########################################################################################################################################################################
--
-- Create Tuning Task
--

DECLARE
  l_sql_tune_task_id  VARCHAR2(100);
BEGIN
  l_sql_tune_task_id := DBMS_SQLTUNE.create_tuning_task (
                          sql_id      => '87s8z2zzpsg88',
                          scope       => DBMS_SQLTUNE.scope_comprehensive,
                          time_limit  => 500,
                          task_name   => '87s8z2zzpsg88_tuning_task11',
                          description => 'Tuning task1 for statement 87s8z2zzpsg88');
  DBMS_OUTPUT.put_line('l_sql_tune_task_id: ' || l_sql_tune_task_id); END; /

--
-- Execute Tuning task
--

EXEC DBMS_SQLTUNE.execute_tuning_task(task_name => '87s8z2zzpsg88_tuning_task11');

--
-- Get the Tuning advisor report
--

set long 65536
set longchunksize 65536
set linesize 200
select dbms_sqltune.report_tuning_task('87s8z2zzpsg88_tuning_task11') from dual;

--
-- Get list of tuning task present in database
--

SELECT TASK_NAME, STATUS FROM DBA_ADVISOR_LOG WHERE TASK_NAME = '&task_name';

--
-- Drop a tuning task
--

execute dbms_sqltune.drop_tuning_task('87s8z2zzpsg88_tuning_task11');

########################################################################################################################################################################
#
# HOW TO RUN SQL TUNING ADVISOR FOR A SQL_ID [AVAILABLE IN AWR]
#
########################################################################################################################################################################
--
-- find the begin snap and end snap of the sql_id
--

select a.instance_number inst_id, a.snap_id,a.plan_hash_value, to_char(begin_interval_time,'dd-mon-yy hh24:mi') btime, abs(extract(minute from (end_interval_time-begin_interval_time)) + extract(hour from (end_interval_time-begin_interval_time))*60 + extract(day from (end_interval_time-begin_interval_time))*24*60) minutes, executions_delta executions, round(ELAPSED_TIME_delta/1000000/greatest(executions_delta,1),4) "avg duration (sec)" from dba_hist_SQLSTAT a, dba_hist_snapshot b where sql_id='&sql_id' and a.snap_id=b.snap_id and a.instance_number=b.instance_number
order by snap_id desc, a.instance_number;

--
-- Create the tuning task
--

DECLARE
  l_sql_tune_task_id  VARCHAR2(100);
BEGIN
  l_sql_tune_task_id := DBMS_SQLTUNE.create_tuning_task (
                          begin_snap  => 235,
                          end_snap    => 240,
                          sql_id      => '24pzs2d6a6b13',
                          scope       => DBMS_SQLTUNE.scope_comprehensive,
                          time_limit  => 60,
                          task_name   => '24pzs2d6a6b13_AWR_tuning_task',
                          description => 'Tuning task for statement 24pzs2d6a6b13  in AWR');
  DBMS_OUTPUT.put_line('l_sql_tune_task_id: ' || l_sql_tune_task_id); END; /

--
-- Execute the tuning task
--

EXEC DBMS_SQLTUNE.execute_tuning_task(task_name => '24pzs2d6a6b13_AWR_tuning_task');

--
-- Get the tuning task recommendation report
--

SET LONG 10000000;
SET PAGESIZE 100000000
 
SET LINESIZE 200
SELECT DBMS_SQLTUNE.report_tuning_task('24pzs2d6a6b13_AWR_tuning_task') AS recommendations FROM dual;

########################################################################################################################################################################
# 
# Enabling and Disabling "ALL" Maintenance Tasks for all Maintenance Windows 
# 
########################################################################################################################################################################

EXECUTE DBMS_AUTO_TASK_ADMIN.DISABLE;
EXECUTE DBMS_AUTO_TASK_ADMIN.ENABLE;

########################################################################################################################################################################
# 
# Enabling and Disabling Maintenance Tasks for all Maintenance Windows 
# 
########################################################################################################################################################################

BEGIN
  dbms_auto_task_admin.disable(
    client_name => 'sql tuning advisor',
    operation   => NULL,
    window_name => NULL);
END;
/

###

BEGIN
  dbms_auto_task_admin.enable(
    client_name => 'sql tuning advisor',
    operation   => NULL,
    window_name => NULL);
END;
/

NOTE: The task names to use for the client_name argument are listed in the DBA_AUTOTASK_CLIENT database dictionary view.

########################################################################################################################################################################
# 
# DATAPUMP: FEW ENHANCEMENTS AND PERFORMANCE RELATED TWEEKS
# 
########################################################################################################################################################################

### Granular Object Filtering Options

database_export_objects
schema_export_objects
table_export_objects

### EXPDP optimization
Use ESTIMATE=STATISTICS if estimated size of the file is not a concern
Use EXCLUDE=STATISTICS, as we have to gather statistics after import job

In 12c database when IMPORT is executed, ensure _OPTIMIZER_GATHER_STATS_ON_LOAD=FALSE, so that stat gather is not initiated after every direct load. This is only restricted on 12c

### Disable Archive Logging during IMPORT
 TRANSFORM=DISABLE_ARCHIVE_LOGGING:Y
 
### Tracking Time
METRICS=YES
LOGTIME=[NONE|STATUS|LOGFILE|ALL]

### Datapump in PL/SQL

dbms_datapump

########################################################################################################################################################################
#
# HOW TO VIEW THE EXPLAIN PLAN FOR THIS SQL STATEMENT FROM AWR AND CURSOR
#
########################################################################################################################################################################

select * from TABLE(dbms_xplan.display_awr('g8375ar84qz62', null, null, 'ALL'));
select * from TABLE(dbms_xplan.display_awr('g8375ar84qz62', 2018123518, null, 'ALL PREDICATE '));

-- FIND SQL_CHILD_NUMBER --
SELECT sql_id, child_number FROM V$SQL WHERE sql_id='bsxhug22k2dqf';

SELECT * FROM TABLE(DBMS_XPLAN.display_cursor(sql_id=>'bsxhug22k2dqf', cursor_child_no => 2, format=>'ALLSTATS LAST +cost +bytes +ROWS +PARTITION +PARALLEL +PREDICATE +PROJECTION'));

########################################################################################################################################################################
#
# Monitor Long Running Queries
#
########################################################################################################################################################################

select s.sid, s.serial#, s.username, s.sql_id, sql.sql_text, s.machine, s.module, s.last_call_et
from gv$session s
left outer join 
gv$sql sql on sql.hash_value=s.sql_hash_value and sql.address=s.sql_address
where 1=1
and s.inst_id=sql.inst_id
and s.username is not null
and s.username not in ('SYS')
and s.status='ACTIVE'
and s.type <> 'BACKGROUND'
-- long running for 2 hours(7200 secs)
and last_call_et >= 7200;

########################################################################################################################################################################
#
# List the patch levels of Database Oracle Home targets monitored by
# Enterprise Manager (EM) 12c Cloud Control via SQL from the repository database.
#
########################################################################################################################################################################

set lin 200 pages 500 pause on
col host_name for a35
col TARGET_NAME for a35
col PATCH_PRODUCT for a25
col PATCH_TYPE for a15
select HOST_NAME, TARGET_NAME, PATCH_ID, PATCH_TYPE, PATCH_PRODUCT
from MGMT$PR_APPL_PATCHES_TO_OH_TGT
where PATCH_PRODUCT = 'Oracle Database' order by 1,2;

or

SQL> select * from mgmt$applied_patches where home_name like 'OraDB%' and rownum < 3;

or

SQL>select distinct a.target_name,a.host_name,b.patch,b.host,b.home_location,b.home_name
from mgmt$target a,MGMT$APPLIED_PATCHES b
where a.host_name=b.host
and a.target_type in ('oracle_database','rac_database')
and b.home_name like 'OraDB%'
and a.target_name='<targetName>';


########################################################################################################################################################################
#
# COMPLETE LIST OF DATABASE HIDDEN PARAMETERS
#
########################################################################################################################################################################

--
-- List all hidden database parameters.
--

SET PAUSE ON
SET PAUSE 'Press Return to Continue'
SET PAGESIZE 60
SET LINESIZE 300

COLUMN ksppinm FORMAT A50
COLUMN ksppstvl FORMAT A50

SELECT
  ksppinm,
  ksppstvl
FROM
  x$ksppi a,
  x$ksppsv b
WHERE
  a.indx=b.indx 
AND
  substr(ksppinm,1,1) = '_'
ORDER BY ksppinm
/

########################################################################################################################################################################
#
# HOW TO MODIFY DATABASE HIDDEN PARAMETERS
#
########################################################################################################################################################################

alter system set "_push_join_predicate"=FALSE scope=spfile sid='*';

########################################################################################################################################################################
#
# FIND MODIFIED DATABASE HIDDEN PARAMETERS
#
########################################################################################################################################################################

col name for A40
col value for A30
set linesize 200
set pagesize 100
 
select name, value from v$parameter where name like '\_%' escape '\';

########################################################################################################################################################################
#
# THROUGHPUT MEASURE OF TRANSFER BITS ACROSS THE MEDIA
# https://blogs.oracle.com/alejandrovargas/useful-scripts
#
########################################################################################################################################################################

set lines 250
set pages 9999
spool sysmetric_output.log
alter session set nls_date_format='dd-mm-yyyy hh24:mi';

select min(begin_time), max(end_time),
       sum(case metric_name when 'Physical Read Total Bytes Per Sec' then average end) Physical_Read_Total_Bps,
       sum(case metric_name when 'Physical Write Total Bytes Per Sec' then average end) Physical_Write_Total_Bps,
       sum(case metric_name when 'Redo Generated Per Sec' then average end) Redo_Bytes_per_sec,
       sum(case metric_name when 'Physical Read Total IO Requests Per Sec' then average end) Physical_Read_IOPS,
       sum(case metric_name when 'Physical Write Total IO Requests Per Sec' then average end) Physical_write_IOPS,
       sum(case metric_name when 'Redo Writes Per Sec' then average end) Physical_redo_IOPS,
       sum(case metric_name when 'Current OS Load' then average end) OS_Load,
       sum(case metric_name when 'CPU Usage Per Sec' then average end) DB_CPU_Usage_per_sec,
       sum(case metric_name when 'Host CPU Utilization (%)' then average end) Host_CPU_util, --NOTE 100% = 1 loaded RAC node
       sum(case metric_name when 'Network Traffic Volume Per Sec' then average end) Network_bytes_per_sec,
       snap_id
from dba_hist_sysmetric_summary
group by snap_id
order by snap_id;
spool off

IOPS = "physical reads total I/O requests" + "physical writes total I/O requests"
MBytes/s = "physical reads total bytes" + "physical writes total bytes"
For RAC environments - aggregate IOPS or MBytes/s for all nodes

########################################################################################################################################################################
#
# SCRIPT TO DETERMINE HOW MUCH IO
# https://blogs.oracle.com/alejandrovargas/useful-scripts
#
########################################################################################################################################################################

SELECT a.sid, a.statistic#, SUBSTR(b.name,1,40) name, a.value
FROM v$sesstat a, v$statname b, v$session se
WHERE se.audsid = (select userenv('sessionid') from dual)
AND a.statistic# = b.statistic#
AND se.sid = a.sid
AND b.name in ('physical read total IO requests','physical read total bytes','physical write total IO requests','physical write total bytes')
ORDER BY b.class, b.name;

IOPS = "physical reads total I/O requests" + "physical writes total I/O requests"
MBytes/s = "physical reads total bytes" + "physical writes total bytes"
For RAC environments - aggregate IOPS or MBytes/s for all nodes

########################################################################################################################################################################
#
# HOW TO ALTER SQL_PLAN_BASELINE
#
########################################################################################################################################################################

declare
abc varchar2(100);
begin
abc := DBMS_SPM.ALTER_SQL_PLAN_BASELINE (plan_name=>'SQL_PLAN_bznpgp10hmuaw7448edbc', attribute_name=>'ENABLED', attribute_value=>'NO') ;
end;
/

########################################################################################################################################################################
#
# FIND PRIMARY - FOREIGN KEY RELATION BETWEEN TABLES
#
########################################################################################################################################################################

set lin 200 pages 500
col parent_table for a20
col parent_column for a20
col constraint_name for a30
col key_type for a13
col child_table for a20
col child_column for a20
select
        ac.owner || '.' || ac.table_name as parent_table  ,
        acc.column_name as parent_column                  ,
        ac.constraint_name                                ,
        decode (ac.constraint_type, 'P', 'PRIMARY KEY', 'FOREIGN KEY') key_type,
        (select ac2.owner || '.' || ac2.table_name from dba_constraints ac2 where ac2.constraint_name = ac.r_constraint_name) child_table,
        (select ac3.column_name from dba_cons_columns ac3 where ac3.constraint_name = ac.r_constraint_name) child_column
from
        dba_cons_columns acc,
        dba_constraints  ac
where
        acc.constraint_name = ac.constraint_name
and     acc.table_name      = ac.table_name
and     ac.constraint_type in ('P', 'R')
and     ac.table_name = 'DEPARTMENTS'
and     ac.owner = 'HR'
order by
        ac.table_name ,
		ac.owner,
        ac.constraint_type;
		
########################################################################################################################################################################
#
# OEM: FIND DATABASE SIZE [USING MGMT VIEWS]
#
########################################################################################################################################################################

set lin 200 pages 500
col TARGET_NAME for a35
col allocated_gb for 999,999,999,999
col used_gb for 999,999,999,999
col allocated_free_gb for 999,999,999,999
select tg.target_name, round (sum (t.tablespace_size / 1024 / 1024 / 1024), 2) as allocated_gb,
round (sum (t.tablespace_used_size / 1024 / 1024 / 1024), 2) as used_gb,
round (sum ((t.tablespace_size - tablespace_used_size) / 1024 / 1024 / 1024),2) as allocated_free_gb
from mgmt$db_tablespaces t,
(select target_name, target_guid from mgmt_targets where target_guid in (select target_guid from mgmt_targets where target_type = 'rac_database')
and (target_type = 'rac_database')) tg
where t.target_guid = tg.target_guid
group by tg.target_name
order by used_gb desc;

########################################################################################################################################################################
#
# READING ALERT LOG VIA SQL
#
########################################################################################################################################################################

set lin 200 pages 5000
col message_text for a150
spool alert.log
select to_char(originating_timestamp, 'MON-DD-YYYY HH24:MI:SS') TIMESTAMP, message_text
from x$dbgalertext where trunc(originating_timestamp) >= to_date('OCT-03-2018 00:00:00', 'MON-DD-YYYY HH24:MI:SS');
spool off

########################################################################################################################################################################
#
# FIND SQL QUERIES EXPERIENCING "LATCHING CACHE LOCK"
# FROM DBA_HIST_ACTIVE_SESS_HISTORY, DBA_HIST_SQLTEXT, DBA_USERS
#
########################################################################################################################################################################

set lin 200 pages 20000
col machine for a25
col module for a15
select c.username, a.SQL_ID, b.sql_text, machine,module
from
dba_hist_active_sess_history a,
dba_hist_sqltext b,
dba_users c
where 1=1
and a.sql_id=b.sql_id
and a.user_id=c.user_id
and SAMPLE_TIME between
	to_date('JUL-15-2018 10:30:44', 'MON-DD-YYYY HH24:MI:SS') and
	to_date('JUL-15-2018 10:45:47', 'MON-DD-YYYY HH24:MI:SS')
and event='library cache lock';

########################################################################################################################################################################
#
# HOW TO BREAK A JOB
#
########################################################################################################################################################################

SQL> exec dbms_ijob.broken(1360,true);

########################################################################################################################################################################
#
# A REPORT OF TABLES WITH MIGRATED OR CHAINED ROWS
#
########################################################################################################################################################################

set pages 9999;
column c1 heading "Owner"   format a9;
column c2 heading "Table"   format a12;
column c3 heading "PCTFREE" format 99;
column c4 heading "PCTUSED" format 99;
column c5 heading "avg row" format 99,999;
column c6 heading "Rows"    format 999,999,999;
column c7 heading "Chains"  format 999,999,999;
column c8 heading "Pct"     format .99; 
set heading off;
select 'Tables with migrated/chained rows and no RAW columns.' from dual;
set heading on;
select 
   owner              c1, 
   table_name         c2, 
   pct_free           c3, 
   pct_used           c4, 
   avg_row_len        c5, 
   num_rows           c6, 
   chain_cnt          c7,
   chain_cnt/num_rows c8
from dba_tables
where
owner not in ('SYS','SYSTEM')
and
table_name not in
 (select table_name from dba_tab_columns
   where
 data_type in ('RAW','LONG RAW','CLOB','BLOB','NCLOB')
 )
and
chain_cnt > 0
order by chain_cnt desc
;

########################################################################################################################################################################
#
# Segment Advisor’s advice via the DBMS_SPACE
#
########################################################################################################################################################################

/* FIRST, CHECK WHEN HAS THE SCHEDULED JOB LAST RUN, AS THE
ADVICE WITH DEPEND ON THE LATEST RUN */

select
segments_processed,
end_time
from dba_auto_segadv_summary
order by end_time;

/* THEN FIRE BELOW QUERY FOR ADVICE */

SELECT
'Segment Advice --------------------------'   || chr(10) ||
'TABLESPACE_NAME   : '  || tablespace_name    || chr(10) ||
'SEGMENT_OWNER     : '  || segment_owner      || chr(10) ||
'SEGMENT_NAME      : '  || segment_name       || chr(10) ||
'ALLOCATED_SPACE   : '  || allocated_space    || chr(10) ||
'RECLAIMABLE_SPACE : '  || reclaimable_space  || chr(10) ||
'RECOMMENDATIONS   : '  || recommendations    || chr(10) ||
'SOLUTION 1        : '  || c1                 || chr(10) ||
'SOLUTION 2        : '  || c2                 || chr(10) ||
'SOLUTION 3        : '  || c3 Advice
FROM
TABLE(dbms_space.asa_recommendations('FALSE', 'FALSE', 'FALSE'));

/* DISPLAYS SEGMENT ADVISOR ADVICE GENERATED WITHIN THE LAST DAY USING DBA_ADVISOR_* VIEWS */

select
'Task Name 			: ' || f.task_name 																	 || chr(10) ||
'Start Run Time : ' || TO_CHAR(execution_start, 'dd-mon-yy hh24:mi')									 || chr(10)||
'Segment Name 	: ' || o.attr2 																			 || chr(10) ||
'Segment Type 	: ' || o.type 																			 || chr(10) ||
'Partition Name : ' || o.attr3 																			 || chr(10) ||
'Message 		: ' || f.message 																		 || chr(10) ||
'More Info 		: ' || f.more_info 																		 || chr(10) ||
'------------------------------------------------------' Advice
FROM dba_advisor_findings f,
dba_advisor_objects o,
dba_advisor_executions e
WHERE o.task_id = f.task_id
AND o.object_id = f.object_id
AND f.task_id = e.task_id
AND e. execution_start > sysdate - 1
AND e.advisor_name = 'Segment Advisor'
ORDER BY f.task_name;

########################################################################################################################################################################
#
# Segment Advisor’s advice MANUALLY
#
########################################################################################################################################################################

###Manually generate advice for a specific segment using DBMS_ADVISOR
package by executing the following steps:-

1. Create a task
2. Assign an object to the task
3. Set the task parameters
4. Execute the task

DECLARE
my_task_id number;
obj_id number;
my_task_name varchar2(100);
my_task_desc varchar2(500);
BEGIN
my_task_name := 'F_REGS Advice';
my_task_desc := 'Manual Segment Advisor Run';
---------
-- Step 1
---------
dbms_advisor.create_task (
advisor_name => 'Segment Advisor',
task_id => my_task_id,
task_name => my_task_name,
task_desc => my_task_desc);
---------
-- Step 2
---------
dbms_advisor.create_object (
task_name => my_task_name,
object_type => 'TABLE',
attr1 => 'SOURAV',
attr2 => 'F_REGS',
attr3 => NULL,
attr4 => NULL,
attr5 => NULL,
object_id => obj_id);
---------
-- Step 3
---------
dbms_advisor.set_task_parameter(
task_name => my_task_name,
parameter => 'recommend_all',
value => 'TRUE');
---------
-- Step 4
---------
dbms_advisor.execute_task(my_task_name);
END;
/

###Then view Segment Advisor view

SELECT
'Segment Advice --------------------------'|| chr(10) ||
'TABLESPACE_NAME   : ' || tablespace_name  || chr(10) ||
'SEGMENT_OWNER     : ' || segment_owner    || chr(10) ||
'SEGMENT_NAME      : ' || segment_name     || chr(10) ||
'ALLOCATED_SPACE   : ' || allocated_space  || chr(10) ||
'RECLAIMABLE_SPACE : ' || reclaimable_space|| chr(10) ||
'RECOMMENDATIONS   : ' || recommendations  || chr(10) ||
'SOLUTION 1        : ' || c1               || chr(10) ||
'SOLUTION 2        : ' || c2               || chr(10) ||
'SOLUTION 3        : ' || c3 Advice
FROM
TABLE(dbms_space.asa_recommendations('TRUE', 'TRUE', 'FALSE'));

## Segment Advisor advice by querying data dictionary views

SELECT
'Task Name      : ' || f.task_name || chr(10) ||
'Segment Name   : ' || o.attr2     || chr(10) ||
'Segment Type   : ' || o.type      || chr(10) ||
'Partition Name : ' || o.attr3     || chr(10) ||
'Message        : ' || f.message   || chr(10) ||
'More Info      : ' || f.more_info TASK_ADVICE
FROM dba_advisor_findings f
,dba_advisor_objects o
WHERE o.task_id = f.task_id
AND o.object_id = f.object_id
AND f.task_name like 'F_REGS Advice'
ORDER BY f.task_name;


########################################################################################################################################################################
#
#  MONITOR RMAN BACKUP PROGRESS
#
########################################################################################################################################################################

select SID, to_char(start_time, 'yyyy-mm-dd hh24:mi:ss') START_TIME,TOTALWORK, sofar,
round((sofar/totalwork) * 100,2) done, sysdate + TIME_REMAINING/3600/24 end_at
from v$session_longops where totalwork > sofar
AND opname NOT LIKE '%aggregate%' AND opname like 'RMAN%'; 

########################################################################################################################################################################
#
#  RMAN: BACKUP JOB HISTORY ELAPSED TIME & MORE
#
########################################################################################################################################################################

-- Most of the columns above have either a obvious meaning or derive directly from the the V$ views, 
-- so they are explained in the Oracle documentation. The few columns I added to the output that need 
-- some additional explaination are the aggregations below:
-- 
-- CF:			Number of controlfile backups included in the backup set
-- DF:			Number of datafile full backups included in the backup set
-- I0:			Number of datafile incremental level-0 backups included in the backup set
-- I1:			Number of datafile incremental level-1 backups included in the backup set
-- L:			Number of archived log backups included in the backup set
-- OUT INST:	Instance where the job was executed and the output is available (see below)
-- 
-- Please note that the aggregations are only shown for the recent backup jobs in the example above, 
-- since they are purged from the catalog after a few days.
-- 
-- Another important thing to note is that in a RAC environment some fields for a RUNNING backup job may 
-- contain invalid information until the backup job is finished. To get consistent information, run this 
-- query on the node where the backup is running.

set lines 220
set pages 1000
col cf for 9,999
col df for 9,999
col round(j.elapsed_seconds/3600,2) heading "ELAPSED|HOURS"
col i0 for 9,999
col i1 for 9,999
col l for 9,999
col start_time for a25
col end_time for a25
col dow for a10
col dow heading "DOW|STARTED"
col output_mbytes for 9,999,999 heading "OUTPUT|MBYTES"
col session_recid for 999999 heading "SESSION|RECID"
col session_stamp for 99999999999 heading "SESSION|STAMP"
col status for a10 trunc
col time_taken_display for a10 heading "TIME|TAKEN"
col output_instance for 9999 heading "OUT|INST"
select
  j.session_recid, j.session_stamp,
  to_char(j.start_time, 'yyyy-mm-dd hh24:mi:ss') start_time,
  to_char(j.end_time, 'yyyy-mm-dd hh24:mi:ss') end_time,
  (j.output_bytes/1024/1024) output_mbytes, j.status, j.input_type,
  decode(to_char(j.start_time, 'd'), 1, 'Sunday', 2, 'Monday',
                                     3, 'Tuesday', 4, 'Wednesday',
                                     5, 'Thursday', 6, 'Friday',
                                     7, 'Saturday') dow,
  round(j.elapsed_seconds/3600,2) , j.time_taken_display,
  x.cf, x.df, x.i0, x.i1, x.l,
  ro.inst_id output_instance
from V$RMAN_BACKUP_JOB_DETAILS j
  left outer join (select
                     d.session_recid, d.session_stamp,
                     sum(case when d.controlfile_included = 'YES' then d.pieces else 0 end) CF,
                     sum(case when d.controlfile_included = 'NO'
                               and d.backup_type||d.incremental_level = 'D' then d.pieces else 0 end) DF,
                     sum(case when d.backup_type||d.incremental_level = 'D0' then d.pieces else 0 end) I0,
                     sum(case when d.backup_type||d.incremental_level = 'I1' then d.pieces else 0 end) I1,
                     sum(case when d.backup_type = 'L' then d.pieces else 0 end) L
                   from
                     V$BACKUP_SET_DETAILS d
                     join V$BACKUP_SET s on s.set_stamp = d.set_stamp and s.set_count = d.set_count
                   where s.input_file_scan_only = 'NO'
                   group by d.session_recid, d.session_stamp) x
    on x.session_recid = j.session_recid and x.session_stamp = j.session_stamp
  left outer join (select o.session_recid, o.session_stamp, min(inst_id) inst_id
                   from GV$RMAN_OUTPUT o
                   group by o.session_recid, o.session_stamp)
    ro on ro.session_recid = j.session_recid and ro.session_stamp = j.session_stamp
where j.start_time > trunc(sysdate)-&NUMBER_OF_DAYS
order by j.start_time;

########################################################################################################################################################################
#
# RMAN: BACKUP SET DETAILS FROM ABOVE SESSION_RECID & SESSION_STAMP
#
########################################################################################################################################################################

set lines 220
set pages 1000
col backup_type for a4 heading "TYPE"
col controlfile_included heading "CF?"
col incremental_level heading "INCR LVL"
col pieces for 999 heading "PCS"
col ROUND(D.ELAPSED_SECONDS/3600,2) heading "ELAPSED|HOURS"
col device_type for a10 trunc heading "DEVICE|TYPE"
col compressed for a4 heading "ZIP?"
col output_mbytes for 9,999,999 heading "OUTPUT|MBYTES"
col input_file_scan_only for a4 heading "SCAN|ONLY"
select
  d.bs_key, d.backup_type, d.controlfile_included, d.incremental_level, d.pieces,
  to_char(d.start_time, 'yyyy-mm-dd hh24:mi:ss') start_time,
  to_char(d.completion_time, 'yyyy-mm-dd hh24:mi:ss') completion_time,
  round(d.elapsed_seconds/3600, 2), d.device_type, d.compressed, (d.output_bytes/1024/1024) output_mbytes, s.input_file_scan_only
from V$BACKUP_SET_DETAILS d
  join V$BACKUP_SET s on s.set_stamp = d.set_stamp and s.set_count = d.set_count
where session_recid = &SESSION_RECID
  and session_stamp = &SESSION_STAMP
order by d.start_time;

########################################################################################################################################################################
#
# RMAN TARGETLESS: DUPLICATE DATABASE
#
########################################################################################################################################################################

$ rman auxiliary /

run
{
allocate auxiliary channel aux1 device type disk;
allocate auxiliary channel aux2 device type disk;
allocate auxiliary channel aux3 device type disk;
duplicate database to orasbp1
spfile
set control_files='+data','+data','+data'
set db_file_name_convert='orasbt1','orasbp1'
set log_file_name_convert='orasbt1','orasbp1'
backup location '+oback';
}

########################################################################################################################################################################
#
# GRANT MULTIPLE PRIVS TO USER/ROLE
#
########################################################################################################################################################################

BEGIN
FOR x IN (
SELECT *
FROM dba_objects
WHERE object_type IN ('TABLE', 'VIEW','SYNONYM')
AND owner in ('SCOTT')
)
LOOP
EXECUTE IMMEDIATE 'grant select,insert,update,delete on ' || x.owner || '."' || x.object_name || '" to scottadm';
END LOOP;
END;
/

########################################################################################################################################################################
#
# FIND BLOCKED OBJECTS AND KILL SESSION
#
########################################################################################################################################################################

select
   c.owner,
   c.object_name,
   c.object_type,
   b.sid,
   b.serial#,
   b.status,
   b.osuser,
   b.machine
from
   v$locked_object a ,
   v$session b,
   dba_objects c
where
   b.sid = a.session_id
and
   a.object_id = c.object_id;

ALTER SYSTEM KILL SESSION 'sid,serial#' IMMEDIATE;

########################################################################################################################################################################
#
# FIND MODES OF LOCKED ROWS AND TRANSACTION DETAILS
# SCRIPT WILL ASK FOR TRANSACTION_ID. PASS THE INFORMATION IN THE FORM OF X.XXX.XXXX (SELECT DBMS_TRANSACTION.LOCAL_TRANSACTION_ID FROM DUAL;)
#
########################################################################################################################################################################

select
    owner               object_owner,
    object_name         object_name,
    session_id          oracle_sid,
    oracle_username     db_user,
    decode(LOCKED_MODE,
        0, 'None',
        1, 'Null',
        2, 'Row Share',
        3, 'Row Exclusive',
        4, 'Share',
        5, 'Sub Share Exclusive',
        6, 'Exclusive',
        locked_mode
    )                   locked_mode
    from v$locked_object lo,
        dba_objects do
    where
        (xidusn||'.'||xidslot||'.'||xidsqn)
            = ('&transid')
    and
        do.object_id = lo.object_id
/

########################################################################################################################################################################
#
# FIND FOR SID & SERIAL# FOR A SCHEMA TO KILL
#
########################################################################################################################################################################

SELECT s.sid, s.serial#, s.status, p.spid 
FROM v$session s, v$process p 
WHERE s.username = 'SYS'
AND p.addr(+) = s.paddr;

ALTER SYSTEM KILL SESSION '141,357' IMMEDIATE;

########################################################################################################################################################################
#	
# IDENTIFY DATABASE SID BASED ON OS PROCESS ID
#
########################################################################################################################################################################

col sid format 999999
col username format a20
col osuser format a15
select b.spid,a.sid, a.serial#,a.username, a.osuser
from v$session a, v$process b
where a.paddr= b.addr
and b.spid='&spid'
order by b.spid;

########################################################################################################################################################################
#	
# IDENTIFY OS PROCESS ID(PID) BASED ON DATABASE SID
#
########################################################################################################################################################################

# use this to find the OS PID and kill -9 it if "ALTER SYSTEM KILL SESSION 'sid,serial#' IMMEDIATE" doesn't work

col sid format 999999
col username format a20
col osuser format a15
select a.sid, a.serial#,a.username, a.osuser, b.spid
from v$session a, v$process b
where a.paddr= b.addr
and a.sid='&sid'
order by a.sid;

########################################################################################################################################################################
#	
# FIX FOR ORA-00054
#
########################################################################################################################################################################

## First identify the SID, SERIAL# and other details to locate correct session information
##

select a.inst_id,a.sid, a.serial#, a.username, a.sql_id, a.state, a.blocking_Session
from gv$session a, gv$locked_object b, dba_objects c
where b.object_id = c.object_id
and a.sid = b.session_id
and OBJECT_NAME='COMPANY_MODEL_VALS';

## Then kill it at SQL level
##

ALTER SYSTEM KILL SESSION 'sid,serial#,@inst_id' IMMEDIATE

## Finally kill at OS level, in case previous step doesn't work
## Ensure connected to correct NODE while executing KILL command

col sid format 999999
col username format a20
col osuser format a15
select a.sid, a.serial#,a.username, a.osuser, b.spid
from v$session a, v$process b
where a.paddr= b.addr
and a.sid=1353
order by a.sid;

OS Propmpt> kill -9 ${SPID}

########################################################################################################################################################################
#	
# WHAT IS GOING ON ...
#
########################################################################################################################################################################

set lin 200 pages 500
col command for a12
select
   substr(s.username,1,18) username,
   substr(s.program,1,15) program,
   decode(s.command,
     0,'No Command',
     1,'Create Table',
     2,'Insert',
     3,'Select',
     6,'Update',
     7,'Delete',
     9,'Create Index',
     15,'Alter Table',
     21,'Create View',
     23,'Validate Index',
     35,'Alter Database',
     39,'Create Tablespace',
     41,'Drop Tablespace',
     40,'Alter Tablespace',
     53,'Drop User',
     62,'Analyze Table',
     63,'Analyze Index',
     s.command||': Other') command,
	 sql_id,
	 event
from
   v$session     s,
   v$process     p,
   v$transaction t,
   v$rollstat    r,
   v$rollname    n
where s.paddr = p.addr
and s.taddr = t.addr (+)
and t.xidusn = r.usn (+)
and r.usn = n.usn (+)
order by 1;

########################################################################################################################################################################
#
# GOLDENGATE: WHEN TO INCREASE INITRANS
#
########################################################################################################################################################################

When encountering deadlock issues, increase INITRANS value to number of replicate + 2
To find INITRANS value, exec
	select table_name,ini_trans from dba_tables where table_name='T1_RPT_MARGIN';
To increase INITRANS value, exec
	alter table mt_rpt01.T1_RPT_MARGIN initrans 15;

What Is Causing A Replicat Deadlock On Oracle? (Doc ID 969579.1)

########################################################################################################################################################################
#	
# LOGIN TO DATABASE WHEN MAXIMUM NUMBER OF PROCESSES (%S) EXCEEDED 
#
########################################################################################################################################################################

sqlplus -prelim "/as sysdba"

########################################################################################################################################################################
#	
# CONNECT TO DATABASE WITHOUT TNSNAMES
#
########################################################################################################################################################################

sqlplus username/password@//hostname or IP address:Port number/oracle sid

sqlplus mt_rpt01/mmdsprpt01@//ewr-reporter-x5.mediamath.com:1521/RPTQA01

########################################################################################################################################################################
#	
# REGISTER DATABASE TO LOCAL LISTENER MANUALLLY
#
########################################################################################################################################################################

alter system set local_listener='(ADDRESS = (PROTOCOL=TCP)(HOST=10.202.32.175)(PORT=1521))';
alter system register;

########################################################################################################################################################################
#
# LIST OF USERS AND ROLES ASSIGNED
#
########################################################################################################################################################################

select grantee,
rtrim (xmlagg (xmlelement (e, GRANTED_ROLE || ',')).extract ('//text()'), ',') GRANTED_ROLE
from DBA_ROLE_PRIVS
where 
grantee in (select username from dba_users) group by  grantee;

########################################################################################################################################################################
#
# IDENTIFY DATABASE IDLE SESSIONS
#
########################################################################################################################################################################

set linesize 200
col username format a15
col idle format a15
col program format a43
col LOGON for a25
col "IDLE (HR:MI:SS)" for a20

PROMPT Enter the number of minutes for which the sessions should have been idle:
PROMPT

select
sid,serial#,username,status,
to_char(logon_time,'dd-mm-yy hh:mi:ss') "LOGON",
floor(last_call_et/3600)||':'||
floor(mod(last_call_et,3600)/60)||':'||
mod(mod(last_call_et,3600),60) "IDLE (HR:MI:SS)",
program
from
v$session
where
type='USER'
and (LAST_CALL_ET / 60) > &minutes
order by last_call_et;

########################################################################################################################################################################
#
# MVIEW: PERFORM ATOMIC MVIEW REFRESH
#
########################################################################################################################################################################

set timing on;
set echo on;
connect mt_rpt01/mmdsprpt01
spool /d1/nfs/oracle_backup/JOHN/CTDALL/mv_refresh.log
EXEC DBMS_MVIEW.REFRESH(LIST => 'T1_RPT_CTD_TXPCY_ALL_MV', METHOD => 'C', ATOMIC_REFRESH => TRUE);
spool off
set timing off
set echo off
exit

########################################################################################################################################################################
#
# DELETE MULTIPLE OBJECTS OF A USER
#
########################################################################################################################################################################

DECLARE
BEGIN
   FOR r1
      IN (  SELECT    'DROP '
                   || object_type
                   || ' '
                   || owner
                   || '.'                   
                   || object_name
                   || DECODE (object_type,'TABLE', ' CASCADE CONSTRAINTS PURGE')
		               || decode (object_type,'TYPE', ' force')		   
                      AS v_sql
              FROM all_objects
             WHERE     owner in ('KOFAXADM')
                   AND object_type IN ('TABLE',
                                       'VIEW',
                                       'PACKAGE',
                                       'TYPE',
                                       'PROCEDURE',
                                       'FUNCTION',
                                       'TRIGGER',
                                       'SEQUENCE',
				       'MATERIALIZED VIEW',
				       'SYNONYM')
          ORDER BY object_type, object_name)
   LOOP
      EXECUTE IMMEDIATE r1.v_sql;
   END LOOP;
END;
/

@$ORACLE_HOME/rdbms/admin/utlrp.sql
exec dbms_stats.gather_schema_stats('EMSDBA',cascade=>true,degree=>4);
exec dbms_stats.gather_table_stats(ownname => 'MT_RPT01', tabname => 'T1_REACH_FREQUENCY' , estimate_percent => 100, cascade => true );
exec dbms_stats.gather_table_stats(ownname => 'MT_RPT01', tabname => 'T1_REACH_FREQUENCY' , estimate_percent => dbms_stats.auto_sample_size, cascade => true );

########################################################################################################################################################################
#
# REFRESH MATERIALIZED VIEWS
#
########################################################################################################################################################################

EXEC DBMS_MVIEW.REFRESH(LIST => 'T1_RPT_7DAY_PERF_CAMPAIGN_MV', METHOD => 'C', ATOMIC_REFRESH => TRUE);

########################################################################################################################################################################
#
# HOW TO ADD "ACL" TO DATABASE
#
########################################################################################################################################################################

select host, acl from dba_network_acls where host='*';

select acl, principal, privilege, is_grant from dba_network_acl_privileges;

----------------------------------------'ACL xml file                       ','SCHEMA' ---------------

BEGIN
  DBMS_NETWORK_ACL_ADMIN.ADD_PRIVILEGE ('network_services_Resolve-Access.xml','CP360',TRUE,'connect');
  DBMS_NETWORK_ACL_ADMIN.ADD_PRIVILEGE ('network_services_Resolve-Access.xml','CP360',TRUE,'resolve');
END;
/

########################################################################################################################################################################
#
# FOR VARIOUS COMPRESSION TYPES YOU CAN REFER TO V$RMAN_COMPRESSION_ALGORITHM
#
########################################################################################################################################################################

SQL> select ALGORITHM_NAME, ALGORITHM_DESCRIPTION, ALGORITHM_COMPATIBILITY from V$RMAN_COMPRESSION_ALGORITHM;

########################################################################################################################################################################
#
# FIND DUPLICAT ROWS
#
########################################################################################################################################################################

select sr_no, name, count(*) from test_emp_detail group by sr_no, name having count(*) > 1;

select sr_no, name from (
select e.*, count(*) over(partition by sr_no, name) ct from test_emp_detail e
)
where ct > 1;

select e.*, count(*) over(partition by sr_no, name) ct from test_emp_detail e;

########################################################################################################################################################################
#
# CREATE MULTIPLE USERS
#
########################################################################################################################################################################

set serveroutput on
declare
  type name is table of varchar2(50);
  n name := name('campbsl', 'martilc', 'mooreka', 'carolr','roulemm','keitha','forsejm','andrujl','melanb','tsec','kbonham');
begin
  for i in n.first .. n.last 
  loop
--    dbms_output.put_line( 'value of a: ' || n(i) );
execute immediate 'CREATE USER ' || n(i) || ' IDENTIFIED BY Good1234 DEFAULT TABLESPACE USERS TEMPORARY TABLESPACE TEMP PROFILE COP_USER_DEFAULT'; 
execute immediate 'grant OPTIX_SECURE, connect, create session to ' || n(i);
execute immediate 'alter user ' || n(i) || ' default role all';
end loop;
end;
/

########################################################################################################################################################################
# 
# USER CREATION:
#
########################################################################################################################################################################

CREATE USER GUERRJR IDENTIFIED BY Good1234 DEFAULT TABLESPACE USERS TEMPORARY TABLESPACE TEMP PROFILE COP_APPL_DEFAULT;
CREATE USER tpm IDENTIFIED BY Good1234 DEFAULT TABLESPACE USERS TEMPORARY TABLESPACE TEMP PROFILE COP_USER_DEFAULT;
CREATE USER DCOER IDENTIFIED BY Good1234 DEFAULT TABLESPACE USERS TEMPORARY TABLESPACE TEMP PROFILE SERVICE_DEFAULT;

########################################################################################################################################################################
#
# DATABASE LINK
#
########################################################################################################################################################################

create database link ORADEHD1.WORLD connect to DCOER identified by Dcoewhm14 using 'ORADEHD1';
create public database link OCGDOFT3.WORLD connect to DOR identified by Good1234 using 'OCGDOFT3';

########################################################################################################################################################################
#
# TOP 10 TABLES AND INDEXES (SIZE WISE)
#
########################################################################################################################################################################

select * from
(select owner,
segment_name,segment_type,tablespace_name,
round(bytes/1024/1024/1024,1) "size_in_GB"
from dba_segments where 
owner='HMSI_USER' 
order by bytes/1024/1024/1024 desc) 
where rownum < 11 order by 5 desc;


########################################################################################################################################################################
#
# RESIZE DATAFILES
#
########################################################################################################################################################################

set linesize 1000 pagesize 0 feedback off trimspool on
with
 hwm as (
  -- get highest block id from each datafiles ( from x$ktfbue as we don't need all joins from dba_extents )
  select /*+ materialize */ ktfbuesegtsn ts#,ktfbuefno relative_fno,max(ktfbuebno+ktfbueblks-1) hwm_blocks
  from sys.x$ktfbue group by ktfbuefno,ktfbuesegtsn
 ),
 hwmts as (
  -- join ts# with tablespace_name
  select name tablespace_name,relative_fno,hwm_blocks
  from hwm join v$tablespace using(ts#)
 ),
 hwmdf as (
  -- join with datafiles, put 5M minimum for datafiles with no extents
  select file_name,nvl(hwm_blocks*(bytes/blocks),5*1024*1024) hwm_bytes,bytes,autoextensible,maxbytes
  from hwmts right join dba_data_files using(tablespace_name,relative_fno)
 )
select
 case when autoextensible='YES' and maxbytes>=bytes
 then -- we generate resize statements only if autoextensible can grow back to current size
  '/* reclaim '||to_char(ceil((bytes-hwm_bytes)/1024/1024),999999)
   ||'M from '||to_char(ceil(bytes/1024/1024),999999)||'M */ '
   ||'alter database datafile '''||file_name||''' resize '||ceil(hwm_bytes/1024/1024)||'M;'
 else -- generate only a comment when autoextensible is off
  '/* reclaim '||to_char(ceil((bytes-hwm_bytes)/1024/1024),999999)
   ||'M from '||to_char(ceil(bytes/1024/1024),999999)
   ||'M after setting autoextensible maxsize higher than current size for file '
   || file_name||' */'
 end SQL
from hwmdf
where
 bytes-hwm_bytes>1024*1024 -- resize only if at least 1MB can be reclaimed
order by bytes-hwm_bytes desc
/

ALTERNATIVE
===========

set linesize 400 pages 999
col tablespace_name format a20
col file_size format 99999999999
col file_name format a60
col hwm format 9999999999
col can_save_MB format 99999999999

SELECT tablespace_name, file_name, file_size, hwm, file_size-hwm can_save_MB
FROM (SELECT /*+ RULE */ ddf.tablespace_name,ddf.file_name file_name,
ddf.bytes/1048576 file_size,(ebf.maximum + de.blocks-1)*dbs.db_block_size/1048576 hwm
FROM dba_data_files ddf,(SELECT file_id, MAX(block_id) maximum FROM dba_extents GROUP BY file_id) ebf,dba_extents de,
(SELECT value db_block_size FROM v$parameter WHERE name='db_block_size') dbs
WHERE ddf.file_id = ebf.file_id
AND de.file_id = ebf.file_id
AND de.block_id = ebf.maximum
ORDER BY 1,2)
order by can_save_MB desc;


#######################################################
#
# DROP PRIVATE DB LINK, INCASE PASSWORD NOT AVAILABLE
#
#######################################################


create procedure WELLS.drop_link as
begin
execute immediate 'drop database link HPS.WORLD';
end;
/

execute WELLS.drop_link;

drop procedure WELLS.drop_link;

################################
#
# MONITOR LONG RUNNING QUERIES
#
################################

ACCEPT active DEFAULT 'y' PROMPT 'Active only processes y/n? [y is default]: '
SET LINES 200 PAGES 0 HEAD OFF LONG 99999999
COL dummy_value NOPRINT
--
SELECT 'dummy_value' dummy_value,
  'USERNAME    : ' || s.username     || CHR(10) ||
  'SCHEMA      : ' || s.schemaname   || CHR(10) ||
  'OSUSER      : ' || s.osuser       || CHR(10) ||
  'MODULE      : ' || s.program      || CHR(10) ||
  'ACTION      : ' || s.schemaname   || CHR(10) ||
  'CLIENT INFO : ' || s.osuser       || CHR(10) ||
  'PROGRAM     : ' || s.program      || CHR(10) ||
  'SPID        : ' || p.spid         || CHR(10) ||
  'SID         : ' || s.sid          || CHR(10) ||
  'SERIAL#     : ' || s.serial#      || CHR(10) ||
  'KILL STRING : ' || '''' || s.sid || ',' || s.serial# || ''''  || CHR(10) ||
  'MACHINE     : ' || s.machine      || CHR(10) ||
  'TYPE        : ' || s.type         || CHR(10) ||
  'TERMINAL    : ' || s.terminal     || CHR(10) ||
  'CPU         : ' || q.cpu_time/1000000     || CHR(10) ||
  'ELAPSED_TIME: ' || q.elapsed_time/1000000/60/60 || CHR(10) ||
  'BUFFER_GETS : ' || q.buffer_gets  || CHR(10) ||
  'SQL_ID      : ' || q.sql_id       || CHR(10) ||
  'CHILD_NUM   : ' || q.child_number || CHR(10) ||
  'START_TIME  : ' || TO_CHAR(s.sql_exec_start,'dd-mon-yy hh24:mi') || CHR(10) ||
  'STATUS      : ' || s.status       || CHR(10) ||
  'SQL_TEXT    : ' || q.sql_fulltext
FROM            gv$session s
JOIN            gv$process p ON (s.paddr  = p.addr)
LEFT OUTER JOIN gv$sql     q ON (s.sql_id = q.sql_id)
WHERE s.username IS NOT NULL -- eliminates background procs
AND NVL(q.sql_text,'x') NOT LIKE '%dummy_value%' -- eliminates this query from output
AND s.status != DECODE('&&active','n','xyz','N','xyz','INACTIVE')
ORDER BY q.cpu_time;

###########################
#
# TABLESPACE UTILIZATION
#
###########################

col TABLESPACE_NAME for a30
set lines 150 pages 100

select avail_tname "TABLESPACE_NAME",sum(round(avail_space,2)) "ALLOCATED (MB)",
((round(avail_space,2)-round(free_space,2))) "USED (MB)",(round(free_space,2)) "FREE (MB)",
(round(((round(avail_space,2)-round (free_space,2))/avail_space)*100,2)) "USED (%)",
(round((free_space/avail_space)*100,2)) "FREE (%)" 
from (select tablespace_name avail_tname,sum(bytes)/1024/1024 avail_space 
from dba_data_files group by tablespace_name) a, 
(select tablespace_name free_tname,sum(bytes)/1024/1024 
free_space from dba_free_space group by tablespace_name) b 
where a.avail_tname=b.free_tname group by avail_tname,avail_space,free_space 
UNION all select avail_tname "TABLESPACE NAME",sum(round(avail_space,2)) "ALLOCATED (MB)", 
((round(avail_space,2)-round(free_space,2))) "USED (MB)", (round(free_space,2)) "FREE (MB)",
(round(((round(avail_space,2)-round(free_space,2))/avail_space)*100,2)) "USED (%)", 
(round((free_space/avail_space)*100,2)) "FREE (%)" from (select tablespace_name avail_tname,
sum(bytes)/1024/1024 avail_space from dba_temp_files group by tablespace_name) a, 
(select tablespace_name free_tname,sum(bytes_free)/1024/1024 free_space from v$temp_space_header group by tablespace_name) 
b where a.avail_tname=b.free_tname group by avail_tname,avail_space,free_space order by 5 desc;


================Find Size in GB================

col TABLESPACE_NAME for a30
set lines 250 pages 500

select avail_tname "TABLESPACE_NAME",sum(round(avail_space,2)) "ALLOCATED (GB)", 
((round(avail_space,2)-round(free_space,2))) "USED (GB)",
(round(free_space,2)) "FREE (GB)",(round(((round(avail_space,2)-round(free_space,2))/avail_space)*100,2)) "USED (%)",
(round((free_space/avail_space)*100,2)) "FREE (%)" from
(select tablespace_name avail_tname,sum(bytes)/1024/1024/1024 avail_space from dba_data_files group by tablespace_name) a,
(select tablespace_name free_tname,sum(bytes)/1024/1024/1024 free_space from dba_free_space group by tablespace_name) b
where a.avail_tname=b.free_tname
group by avail_tname,avail_space,free_space
UNION all
select avail_tname "TABLESPACE NAME",sum(round(avail_space,2)) "ALLOCATED (GB)",
((round(avail_space,2)-round(free_space,2))) "USED (GB)",
(round(free_space,2)) "FREE (GB)",(round(((round(avail_space,2)-round(free_space,2))/avail_space)*100,2)) "USED (%)",
(round((free_space/avail_space)*100,2)) "FREE (%)" from
(select tablespace_name avail_tname,sum(bytes)/1024/1024/1024 avail_space from dba_temp_files group by tablespace_name) a,
(select tablespace_name free_tname,sum(bytes_free)/1024/1024/1024 free_space from v$temp_space_header group by tablespace_name) b
where a.avail_tname=b.free_tname
group by avail_tname,avail_space,free_space
order by 5 desc;


====================================================================================

set lin 200 pages 500 feedback off
select	avail_tname "TABLESPACE_NAME",
		sum(round(max_avail_space,2)) "MAX-ALLOCATION (GB)",
		(round(alloc_avail_space,2)-round(free_space,2)) "USED (GB)",
		((round(free_space,2))+round(max_avail_space,2)-round(alloc_avail_space,2)) "FREE (GB)",
		(round(((round(alloc_avail_space,2)-round(free_space,2))/max_avail_space)*100,2)) "USED (%)",
		(round((((round(free_space,2))+round(max_avail_space,2)-round(alloc_avail_space,2))/max_avail_space)*100,2)) "FREE (%)"
from
		(select	avail_tname,
				sum(alloc_avail_space) alloc_avail_space,
				sum(max_avail_space) max_avail_space
		from	(select	tablespace_name avail_tname,
						round(sum(BYTES)/1024/1024/1024,2) alloc_avail_space,
						decode (autoextensible,'YES',round(sum(MAXBYTES)/1024/1024/1024, 2),
						round(sum(BYTES)/1024/1024/1024, 2)) max_avail_space,
						autoextensible 
				from	dba_data_files
				group by	tablespace_name,
							autoextensible)
		group by	avail_tname) a,
		(select	tablespace_name free_tname,
				sum(bytes)/1024/1024/1024 free_space
		from	dba_free_space
		group by	tablespace_name) b
where	a.avail_tname=b.free_tname 
--
-- UNcomment below line to get ONLY permanent tablespaces above 90% usage only
-- 
-- and (round(((round(alloc_avail_space,2)-round(free_space,2))/max_avail_space)*100,2)) >= 90
group by	avail_tname,
			alloc_avail_space,
			max_avail_space,
			free_space
UNION all
select	avail_tname "TABLESPACE_NAME",
		sum(round(max_avail_space,2)) "MAX-ALLOCATION (GB)",
		(round(alloc_avail_space,2)-round(free_space,2)) "USED (GB)",
		((round(free_space,2))+round(max_avail_space,2)-round(alloc_avail_space,2)) "FREE (GB)",
		(round(((round(alloc_avail_space,2)-round(free_space,2))/max_avail_space)*100,2)) "USED (%)",
		(round((((round(free_space,2))+round(max_avail_space,2)-round(alloc_avail_space,2))/max_avail_space)*100,2)) "FREE (%)"
from
		(select	avail_tname,
				sum(alloc_avail_space) alloc_avail_space,
				sum(max_avail_space) max_avail_space
		from
				(select	tablespace_name avail_tname,
						round(sum(BYTES)/1024/1024/1024,2) alloc_avail_space,
						decode (autoextensible,'YES',round(sum(MAXBYTES)/1024/1024/1024, 2),
						round(sum(BYTES)/1024/1024/1024, 2)) max_avail_space,
						autoextensible
				from	dba_temp_files
				group by	tablespace_name,
							autoextensible)
		group by	avail_tname) a,
		(select	tablespace_name free_tname,
				sum(bytes_free)/1024/1024/1024 free_space
		from	v$temp_space_header
		group by	tablespace_name) b
where	a.avail_tname=b.free_tname
--
-- UNcomment below line to get ONLY temp tablespaces above 90% usage only
--
-- and (round(((round(alloc_avail_space,2)-round(free_space,2))/max_avail_space)*100,2)) >= 90
group by	avail_tname,
			alloc_avail_space,
			max_avail_space,
			free_space
order by	5 desc;


============

SELECT TABLESPACE_NAME, SUM(BYTES/1024/1024) "Size (MB)"  FROM DBA_FREE_SPACE where tablespace_name like 'UNDOTBS%' GROUP BY TABLESPACE_NAME;

================Find Size when autoextend on================

select tablespace_name,
round(sum(bytes/1073741824),2) gbytes,
round(sum(maxbytes/1073741824),2) gmaxbytes,
round((sum(bytes/1073741824))/(sum(maxbytes/1073741824))*100, 2) allocate_pct
from dba_data_files
where AUTOEXTENSIBLE='YES'
group by tablespace_name
order by allocate_pct desc;

#######################################################
#
# FIND WHETHER ARCHIVES APPLIED ON DR [RUN ON PRIMARY]
#
########################################################

set line 200 
select THREAD#, ARCHIVED_primary, ARCHIVED_stdby,APPLIED_stdby ,ARCHIVED_primary-APPLIED_stdby "APPLY DIFF", ARCHIVED_primary-ARCHIVED_stdby "Xfer Diff" ,DB_NAME,OPEN_MODE from 
(Select a.THREAD#,
max(case when a.ARCHIVED='YES' and a.STANDBY_DEST='NO' then a.sequence# end) ARCHIVED_primary,
max(case when a.ARCHIVED='YES' and a.STANDBY_DEST='YES' then a.sequence# end) ARCHIVED_stdby,
max(case when a.APPLIED='YES' and a.STANDBY_DEST='YES' then a.sequence# end) APPLIED_stdby,
max(b.name) DB_NAME, max(b.open_mode) OPEN_MODE 
from v$archived_log a, v$database b group by a.THREAD#);

###################################################################
#
# CHECK DR DATABASE IS IN SYNC OR HAS GAP WITH PRIMARY DATABASE [RUN ON DR]
#
###################################################################

SELECT name, database_role, ARCH.THREAD# "Thread", ARCH.SEQUENCE# "Last Sequence Received",
APPL.SEQUENCE# "Last Sequence Applied", (ARCH.SEQUENCE# - APPL.SEQUENCE#) "Difference"
FROM
(SELECT THREAD# ,SEQUENCE#
FROM V$ARCHIVED_LOG WHERE (THREAD#,FIRST_TIME ) IN (SELECT THREAD#,MAX(FIRST_TIME) FROM V$ARCHIVED_LOG GROUP BY THREAD#)) ARCH,
(SELECT THREAD# ,SEQUENCE# FROM V$LOG_HISTORY
WHERE (THREAD#,FIRST_TIME) IN (SELECT THREAD#,MAX(FIRST_TIME) 
FROM V$LOG_HISTORY GROUP BY THREAD#)) APPL, v$database WHERE ARCH.THREAD# = APPL.THREAD# ORDER BY 1;

OR

set linesize 2000
select sysdate,sum(apply_finish) apply_finish,
sum(apply_lag) apply_lag,
sum(transport_lag) transport_lag,
sum(startup_time) startup_time,
min(TIME_COMPUTED) TIME_COMPUTED
from
(
select
decode(name,'apply finish time',to_number(substr(value,2,2))*86400+to_number(substr(value,5,2))*3600 +to_number(substr(value,8,2))*60 +to_number(substr(value,11,2)),0) apply_finish,
decode(name,'apply lag',to_number(substr(value,2,2))*86400+to_number(substr(value,5,2))*3600 +to_number(substr(value,8,2))*60 +to_number(substr(value,11,2)),0) apply_lag,
decode(name,'transport lag',to_number(substr(value,2,2))*86400+to_number(substr(value,5,2))*3600 +to_number(substr(value,8,2))*60 +to_number(substr(value,11,2)),0) transport_lag,
decode(name ,'estimated startup time',value,0) startup_time,
TIME_COMPUTED
from v$dataguard_stats
where name in (
'apply finish time',
'apply lag',
'estimated startup time',
'transport lag' )
);

###################################################################
#
# RMAN: RESTORE ARCHIVELOGS FROM ASM
#
###################################################################

run
{
allocate channel c1 device type SBT_TAPE;
allocate channel c2 device type SBT_TAPE;
allocate channel c3 device type SBT_TAPE;
allocate channel c4 device type SBT_TAPE;
allocate channel c5 device type SBT_TAPE;
set archivelog destination to '/backup/RMAN_BKP/new1';
restore archivelog from sequence 8884 until sequence 8898 thread 1;
release channel c1;
release channel c2;
release channel c3;
release channel c4;
release channel c5;
}

###################################################################
#
# DATAGUARD: REGISTER ARCHIVELOGS MANUALLY
#
###################################################################

SQL> alter database recover managed standby database cancel;
SQL> alter database register logfile '/backup/rman/new2/2_5757_947689636.dbf';
SQL> alter database recover managed standby database disconnect nodelay;

###################################################################
#
# LIST DATAFILE COUNT IN ASM DISKGROUP
#
###################################################################

select 'Data Files' type,substr(name,1,instr(name,'/',1,2)-1) asm_dg, count(*) cnt from v$datafile
group by substr(name,1,instr(name,'/',1,2)-1)
union
select 'Temp Files',substr(name,1,instr(name,'/',1,2)-1) asm_dg, count(*) cnt from v$tempfile
group by substr(name,1,instr(name,'/',1,2)-1)
union
select 'Redo Member',substr(member,1,instr(member,'/',1,2)-1) asm_dg, count(*) cnt from v$logfile
group by substr(member,1,instr(member,'/',1,2)-1);

##############################################
#
# CREATE DATABASE
#
##############################################

CREATE DATABASE ORCL1
USER SYS IDENTIFIED BY ashwini
USER SYSTEM IDENTIFIED BY ashwini
LOGFILE GROUP 1 ('/u01/app/oracle/oradata/orcl/log/redo01a.log','/u01/app/oracle/oradata/orcl/log/redo01b.log') SIZE 100M BLOCKSIZE 512,
        GROUP 2 ('/u01/app/oracle/oradata/orcl/log/redo02a.log','/u01/app/oracle/oradata/orcl/log/redo02b.log') SIZE 100M BLOCKSIZE 512,
        GROUP 3 ('/u01/app/oracle/oradata/orcl/log/redo03a.log','/u01/app/oracle/oradata/orcl/log/redo03b.log') SIZE 100M BLOCKSIZE 512
MAXLOGHISTORY 1
MAXLOGFILES 16
MAXLOGMEMBERS 3
MAXDATAFILES 1024
CHARACTER SET WE8ISO8859P1
NATIONAL CHARACTER SET AL16UTF16
EXTENT MANAGEMENT LOCAL
DATAFILE '/u01/app/oracle/oradata/orcl/system01.dbf'
SIZE 700M REUSE AUTOEXTEND ON NEXT 10240K MAXSIZE UNLIMITED
SYSAUX DATAFILE '/u01/app/oracle/oradata/orcl/sysaux01.dbf'
SIZE 550M REUSE AUTOEXTEND ON NEXT 10240K MAXSIZE UNLIMITED
DEFAULT TABLESPACE users
DATAFILE '/u01/app/oracle/oradata/orcl/users01.dbf'
SIZE 500M REUSE AUTOEXTEND ON MAXSIZE UNLIMITED
DEFAULT TEMPORARY TABLESPACE tempts1
TEMPFILE '/u01/app/oracle/oradata/orcl/temp01.dbf'
SIZE 20M REUSE AUTOEXTEND ON NEXT 640K MAXSIZE UNLIMITED
UNDO TABLESPACE undotbs1
DATAFILE '/u01/app/oracle/oradata/orcl/undotbs01.dbf'
SIZE 200M REUSE AUTOEXTEND ON NEXT 5120K MAXSIZE UNLIMITED;

In SQL*Plus, connect to your Oracle Database instance with the SYSDBA administrative privilege:

@?/rdbms/admin/catalog.sql
@?/rdbms/admin/catproc.sql

In SQL*Plus, connect to your Oracle Database instance as SYSTEM user:

@?/sqlplus/admin/pupbld.sql

##############################################
#
# LOOP EXISTING COMMAND - ALTERNATE TO WATCH
#
##############################################

while true; do date; ls -lrt; sleep 1; clear; done

watch -n 1 -d ls -lrt

##############################################
#
# SNAPSHOT TOO OLD FIX
#
##############################################

SYS@RPTQA01> @para undo

NAME                                 TYPE       VALUE
------------------------------------ ---------- ------------------------------
undo_management                      string     AUTO
undo_retention                       integer    900
undo_tablespace                      string     UNDOTBS1

Longest query in last 1 day in RPTQA01:
=============================

SYS@RPTQA01> select dbms_undo_adv.longest_query(sysdate-1,sysdate) from dual;

DBMS_UNDO_ADV.LONGEST_QUERY(SYSDATE-1,SYSDATE)
----------------------------------------------
                                         17137

1 row selected.

As per Oracle recommendation, UNDO_RETENTION value:
============================================

SYS@RPTQA01> select dbms_undo_adv.required_retention from dual;

REQUIRED_RETENTION
------------------
             32222

1 row selected.

Altered UNDO_RETENTION:
=====================

SYS@RPTQA01> alter system set undo_retention=32222;

System altered.

SYS@RPTQA01> @para undo

NAME                                 TYPE       VALUE
------------------------------------ ---------- ------------------------------
undo_management                      string     AUTO
undo_retention                       integer    32222
undo_tablespace                      string     UNDOTBS1

##############################################
#
# PERCENTAGE COMPLETED FOR LONG RUNNING QUERIES
#
##############################################

set lin 200 pages 500
col OPNAME for a34
COL pct_complete FORM 99.99 HEAD "% Comp."
COL start_time FORM A15 HEAD "Start|Time"
COL curr_time FORM A15 HEAD "Current|Time"
COL hours_running FORM 9999.99 HEAD "Hours|Running"
COL minutes_left FORM 999999 HEAD "Minutes|Left"
COL est_comp_time FORM A15 HEAD "Est. Comp.|Time"
SELECT sid, serial#, opname,
ROUND(sofar/totalwork*100,2) AS pct_complete,
TO_CHAR(start_time,'dd-mon-yy hh24:mi') start_time,
(sysdate-start_time)*24 hours_running,
((sysdate-start_time)*24*60)/(sofar/totalwork) - (sysdate-start_time)*24*60 minutes_left,
TO_CHAR((sysdate-start_time)/(sofar/totalwork) + start_time,'dd-mon-yy hh24:mi') est_comp_time
FROM  v$session_longops
where   totalwork != 0
AND   sofar <> totalwork;
###################################################
#
# FIND FULLY QUALIFIED DOMAIN NAME IN UNIX SERVER
#
###################################################

echo `uname -n`.`awk '/^domain/ {print $2}' /etc/resolv.conf`

########################################
#
# FIND CURRENT SCHEMA AND CURRENT USER
#
########################################

select sys_context('USERENV','SESSION_USER') from dual;
select sys_context('USERENV','SESSION_SCHEMA') from dual;

################################
#
# EXTRACT USER CREATION SCRIPT
#
################################

SELECT 'GRANT ' || GRANTED_ROLE || ' TO U1;' FROM DBA_ROLE_PRIVS WHERE GRANTEE='DCOEMUWI';
select 'GRANT ' || PRIVILEGE || ' TO U1;' FROM DBA_SYS_PRIVS WHERE GRANTEE='DCOEMUWI';

##############################################################
#
# SCRIPT WILL SHOW BASIC INFORMATION ABOUT CONNECTED DATABASE
# THIS CAN BE USED IN $ORACLE_HOME/SQLPLUS/ADMIN/GLOGIN.SQL
#
##############################################################


set lin 200 pages 500 long 9999999
set feedback off
alter session set NLS_DATE_FORMAT='DD-MON-YYYY HH:MI:SS AM';
set describe depth 1 linenum on indent on
set feedback on
--
--
col segment_name for a25
col tname for a45
col index_name for a25
col tablespace_name for a30
col directory_path for a65
col "Database Details" for a55
col object_name for a35
col owner for a10
col osuser for a10
col machine for a35
col name for a52
col member for a52
col file_name for a50
col machine for a25
col username for a15
col event for a35
col last_update_time for a38
col window_group for a20
col client_name for a33
col consumer_group for a18
col attribute for a30
col status for a20
col extension_name for a20
col extension for a80
col table_name for a37
--
--
set feedback off
set und "="
select
'Database Name     : '|| name             || chr(10) ||
'Database State    : '|| open_mode        || chr(10) ||
'Archive Mode      : '|| log_mode         || chr(10) ||
'Host Machine      : '|| upper(host_name) || chr(10) ||
'Host OS           : '|| platform_name    || chr(10) ||
'Create Date       : '|| created          || chr(10) ||
'Last Startup Time : '|| startup_time     || chr(10) ||
'Up Since          : '|| trunc(sysdate-startup_time)                    || ' days ' ||
                         trunc(mod((sysdate-startup_time)*24, 24))      || ' hrs '  ||
                         trunc(mod((sysdate-startup_time)*24*60, 60))   || ' mins'
"Database Details" from v$database, v$instance;
set feedback on
set und "-"
set sqlprompt "_user'@'_connect_identifier> "
cl buff

##########################################
#
# ARCHIVE LOG GENERATION
#
##########################################

ARCHIVELOG GENERATION ON A DAILY BASIS (LAST 3 DAYS):
=====================================================
select trunc(completion_time) rundate
,count(*)  logswitch
,round((sum(blocks*block_size)/1024/1024)) "REDO PER DAY (MB)"
from v$archived_log
where trunc(completion_time) > sysdate - 3
group by trunc(completion_time)
order by 1;

-------

set pages 1000
select trunc(COMPLETION_TIME,'DD') Day, thread#, round(sum(BLOCKS*BLOCK_SIZE)/1048576) MB,count(*) Archives_Generated from v$archived_log
group by trunc(COMPLETION_TIME,'DD'),thread# order by 1;


ARCHIVE LOG GENERATION ON AN HOURLY BASIS:
==========================================
set pages 1000
select trunc(COMPLETION_TIME,'HH') Hour,thread# , round(sum(BLOCKS*BLOCK_SIZE)/1048576) MB,count(*) Archives from v$archived_log
group by trunc(COMPLETION_TIME,'HH'),thread#  order by 1 ;



REDO LOG SWITCHES ON AN HOURLY BASIS THAT HAPPENED IN THE PAST ONE WEEK:
==========================================================================
alter session set nls_date_format='MON-DD-YYYY';
set lin 200 pages 500
col "00" for a4
col "01" for a4
col "02" for a4
col "03" for a4
col "04" for a4
col "05" for a4
col "06" for a4
col "07" for a4
col "08" for a4
col "09" for a4
col "10" for a4
col "11" for a4
col "12" for a4
col "13" for a4
col "14" for a4
col "15" for a4
col "16" for a4
col "17" for a4
col "18" for a4
col "19" for a4
col "20" for a4
col "21" for a4
col "22" for a4
col "23" for a4
SELECT to_date(first_time) DAY,
to_char(sum(decode(to_char(first_time,'HH24'),'00',1,0)),'999') "00",
to_char(sum(decode(to_char(first_time,'HH24'),'01',1,0)),'999') "01",
to_char(sum(decode(to_char(first_time,'HH24'),'02',1,0)),'999') "02",
to_char(sum(decode(to_char(first_time,'HH24'),'03',1,0)),'999') "03",
to_char(sum(decode(to_char(first_time,'HH24'),'04',1,0)),'999') "04",
to_char(sum(decode(to_char(first_time,'HH24'),'05',1,0)),'999') "05",
to_char(sum(decode(to_char(first_time,'HH24'),'06',1,0)),'999') "06",
to_char(sum(decode(to_char(first_time,'HH24'),'07',1,0)),'999') "07",
to_char(sum(decode(to_char(first_time,'HH24'),'08',1,0)),'999') "08",
to_char(sum(decode(to_char(first_time,'HH24'),'09',1,0)),'999') "09",
to_char(sum(decode(to_char(first_time,'HH24'),'10',1,0)),'999') "10",
to_char(sum(decode(to_char(first_time,'HH24'),'11',1,0)),'999') "11",
to_char(sum(decode(to_char(first_time,'HH24'),'12',1,0)),'999') "12",
to_char(sum(decode(to_char(first_time,'HH24'),'13',1,0)),'999') "13",
to_char(sum(decode(to_char(first_time,'HH24'),'14',1,0)),'999') "14",
to_char(sum(decode(to_char(first_time,'HH24'),'15',1,0)),'999') "15",
to_char(sum(decode(to_char(first_time,'HH24'),'16',1,0)),'999') "16",
to_char(sum(decode(to_char(first_time,'HH24'),'17',1,0)),'999') "17",
to_char(sum(decode(to_char(first_time,'HH24'),'18',1,0)),'999') "18",
to_char(sum(decode(to_char(first_time,'HH24'),'19',1,0)),'999') "19",
to_char(sum(decode(to_char(first_time,'HH24'),'20',1,0)),'999') "20",
to_char(sum(decode(to_char(first_time,'HH24'),'21',1,0)),'999') "21",
to_char(sum(decode(to_char(first_time,'HH24'),'22',1,0)),'999') "22",
to_char(sum(decode(to_char(first_time,'HH24'),'23',1,0)),'999') "23"
from
v$log_history
where to_date(first_time) > sysdate - 7
GROUP by
to_char(first_time,'YYYY-MON-DD'), to_date(first_time)
order by to_date(first_time);

########################################################################################################################################################################
#
# SQL QUERY TO FIND THE CAUSE OR REASON FOR MORE ARCHIVE LOG GENERATION
#
########################################################################################################################################################################
### find the table(s) or object(s) which has been undergone for more number of db block changes.

SELECT
  to_char(begin_interval_time, 'YYYY_MM_DD HH24:MI') snap_time,
  dhsso.object_name,
  SUM(db_block_changes_delta) AS maxchanges
FROM dba_hist_seg_stat dhss,
     dba_hist_seg_stat_obj dhsso,
     dba_hist_snapshot dhs
WHERE dhs.snap_id = dhss.snap_id
AND dhs.instance_number = dhss.instance_number
AND dhss.obj# = dhsso.obj#
AND dhss.dataobj# = dhsso.dataobj#
AND begin_interval_time BETWEEN to_date('2014-03-02 17:00:00', 'YYYY-MM-DD HH24:MI:SS')
AND to_date('2014-03-02 20:00:00', 'YYYY-MM-DD HH24:MI:SS')
GROUP BY to_char(begin_interval_time, 'YYYY-MM-DD HH24:MI:SS'),
         dhsso.object_name
ORDER BY maxchages ASC;

### find the sql statement caused more archive log generation using the above object & below sql query.


col SQL_TEXT for a60
SELECT to_char(begin_interval_time,'YYYY_MM_DD HH24:MI'),
         dbms_lob.substr(sql_text,5000,1),
         dhss.instance_number,
         dhss.sql_id,executions_delta,rows_processed_delta
  FROM dba_hist_sqlstat dhss,
         dba_hist_snapshot dhs,
         dba_hist_sqltext dhst
  WHERE upper(dhst.sql_text) LIKE '%STAGED_MESSAGE%'
    AND dhss.snap_id=dhs.snap_id
    AND dhss.instance_Number=dhs.instance_number
 AND begin_interval_time BETWEEN to_date('2014-03-02 17:00:00','YYYY-MM-DD HH24:MI:SS')
                                           AND to_date('2014-03-02 20:00:00','YYYY-MM-DD HH24:MI:SS')
    AND dhss.sql_id = dhst.sql_id;


### find the user id and program using the sql_id from the above ouput


SELECT
  to_char(sample_time, 'yyyy_mm_dd hh24:mi:ss'),
  user_id,
  program
FROM dba_hist_active_sess_history
WHERE sql_id IN ('5bpaj6hmpjq5h', 'c3utht63bffn9', '86vxuhgt0fc80', 'aqkdd2dgqqr4p')
AND to_char(sample_time, 'YYYY-MM-DD HH24:MI:SS') BETWEEN '2014-03-02 17:00:00' AND '2014-03-02 20:00:00'
ORDER BY 1;	

########################################################################################################################################################################
#
# PERFORMANCE TUNING: AWR PLAN CHANGE
#
########################################################################################################################################################################

col execs for 999,999,999
col avg_etime for 999,999.999
col avg_lio for 999,999,999.9
col begin_interval_time for a30
col node for 99999
break on plan_hash_value on startup_time skip 1
select ss.snap_id, ss.instance_number node, begin_interval_time, sql_id, plan_hash_value,
nvl(executions_delta,0) execs,
(elapsed_time_delta/decode(nvl(executions_delta,0),0,1,executions_delta))/1000000 avg_etime,
(buffer_gets_delta/decode(nvl(buffer_gets_delta,0),0,1,executions_delta)) avg_lio
from DBA_HIST_SQLSTAT S, DBA_HIST_SNAPSHOT SS
where sql_id = nvl('&sql_id','xxxxxxxxxxxxx')
and ss.snap_id = S.snap_id
and ss.instance_number = S.instance_number
and executions_delta > 0
order by 1, 2, 3;

########################################################################################################################################################################
#
# LIST OF ASM DISK GROUP AND SIZE DETAILS
#
########################################################################################################################################################################

set lines 255 pages 500
col path for a35
col Diskgroup for a15
col DiskName for a20
col disk# for 999
col total_mb for 999,999,999
col free_mb for 999,999,999
compute sum of total_mb on DiskGroup
compute sum of free_mb on DiskGroup
break on DiskGroup skip 1 on report -

select a.name DiskGroup, b.disk_number Disk#, b.name DiskName,
b.total_mb, b.free_mb, b.path, b.header_status
from v$asm_disk b, v$asm_diskgroup a
where a.group_number (+) =b.group_number
order by b.group_number, b.disk_number, b.name;

###########

set lin 200 pages 500
col name for a25
select
name,decode(type,'NORMAL',2,'HIGH',3,'EXTERN',1) Redundancy,
(total_mb/decode(type,'NORMAL',2,'HIGH',3,'EXTERN',1)) Total_MB,
(free_mb/decode(type,'NORMAL',2,'HIGH',3,'EXTERN',1)) Free_MB,
round(((free_mb/decode(type,'NORMAL',2,'HIGH',3,'EXTERN',1))/(total_mb/decode(type,'NORMAL',2,'HIGH',3,'EXTERN',1)))*100,2) "%Free"
from v$asm_diskgroup;

########################################################################################################################################################################
#
# CREATE ASM DISKGROUP H I G H REDUNDANCY
#
########################################################################################################################################################################

CREATE DISKGROUP oback HIGH REDUNDANCY
FAILGROUP oback_fg_1
DISK
'/dev/oracleasm/disks/ASMDISK05' NAME oback_ASMDISK05,
'/dev/oracleasm/disks/ASMDISK06' NAME oback_ASMDISK06,
'/dev/oracleasm/disks/ASMDISK07' NAME oback_ASMDISK07
FAILGROUP oback_fg_2
DISK
'/dev/oracleasm/disks/ASMDISK08' NAME oback_ASMDISK08,
'/dev/oracleasm/disks/ASMDISK09' NAME oback_ASMDISK09,
'/dev/oracleasm/disks/ASMDISK10' NAME oback_ASMDISK10
FAILGROUP oback_fg_3
DISK
'/dev/oracleasm/disks/ASMDISK11' NAME oback_ASMDISK11,
'/dev/oracleasm/disks/ASMDISK12' NAME oback_ASMDISK12,
'/dev/oracleasm/disks/ASMDISK13' NAME oback_ASMDISK13
ATTRIBUTE
'au_size'='4M',
'compatible.asm' = '11.2', 
'compatible.rdbms' = '11.2';

########################################################################################################################################################################
#
# CREATE ASM DISKGROUP N O R M A L REDUNDANCY
#
########################################################################################################################################################################

CREATE DISKGROUP oback normal REDUNDANCY
FAILGROUP oback_fg_1
DISK
'ORCL:ASMDISK05' NAME oback_ASMDISK05,
'ORCL:ASMDISK06' NAME oback_ASMDISK06,
'ORCL:ASMDISK07' NAME oback_ASMDISK07
FAILGROUP oback_fg_2
DISK
'ORCL:ASMDISK08' NAME oback_ASMDISK08,
'ORCL:ASMDISK09' NAME oback_ASMDISK09,
'ORCL:ASMDISK10' NAME oback_ASMDISK10
ATTRIBUTE
'au_size'='4M',
'compatible.asm' = '11.2', 
'compatible.rdbms' = '11.2';

######################################################################################################################################################################## 
#
# CREATE ASM DISKGROUP E X T E R N A L REDUNDANCY
#
########################################################################################################################################################################
    
CREATE DISKGROUP redo external REDUNDANCY
DISK
'ORCL:ASMDISK14' NAME redo_ASMDISK14
ATTRIBUTE
'au_size'='4M',
'compatible.asm' = '11.2', 
'compatible.rdbms' = '11.2';

######################################################################################################################################################################## 
#
# Identifying whether a database was created as 32-bit or 64-bit
#
######################################################################################################################################################################## 

DOC>###########################################################################
DOC>
DOC> Result referencing the string 'B023' ==> Database was created as 32-bit
DOC> Result referencing the string 'B047' ==> Database was created as 64-bit
DOC> When String results in 'B023' and when upgrading database to 10.2.0.3.0
DOC> (64-bit) , For known issue refer below articles
DOC>
DOC> Note 412271.1 ORA-600 [22635] and ORA-600 [KOKEIIX1] Reported While
DOC>               Upgrading Or Patching Databases To 10.2.0.3
DOC> Note 579523.1 ORA-600 [22635], ORA-600 [KOKEIIX1], ORA-7445 [KOPESIZ] and
DOC>              OCI-21500 [KOXSIHREAD1] Reported While Upgrading To 11.1.0.6
DOC>
DOC>###########################################################################
DOC>#

SELECT SUBSTR(metadata,109,4) "Metadata",
CASE SUBSTR(metadata,109,4)
WHEN 'B023' THEN 'Database was created as 32-bit'
WHEN 'B047' THEN 'Database was created as 64-bit'
ELSE 'Metadata not Matching'
END "Initial DB Creation Info"
FROM sys.kopm$;

Metadata Initial DB Creation Info
-------- -----------------------------------
B047     Database was created as 64-bit

########################################################################################################################################################################
#
# RMAN: CONFIGURE TEST SBT CHANNEL (ONLY ON FILESYSTEM)
#
########################################################################################################################################################################

run
{
﻿allocate channel sbt1 device type sbt parms='SBT_LIBRARY=oracle.disksbt,ENV=(BACKUP_DIR=+oback)';
backup archivelog all delete all input;
}

RMAN> configure channel sbt1 device type sbt parms='SBT_LIBRARY=oracle.disksbt,ENV=(BACKUP_DIR=+oback)';

########################################################################################################################################################################
#
# RECOVER DATABASE FROM LOSS OF REDO LOG GROUP
#
########################################################################################################################################################################


alter database mount;
alter database clear logfile group 1; -- ensure correct group is mentioned
or
alter database clear unarchived logfile group 1; -- use this incase current group is corrupted
alter database open;

# backup full database

########################################################################################################################################################################
#
# FIND LIST OF AWR SNAPSHOT
#
########################################################################################################################################################################

select snap_id,
  snap_level,
  to_char(begin_interval_time, 'dd/mm/yy hh24:mi:ss') begin
from
   dba_hist_snapshot
order by 1;

########################################################
#
# CREATE MANUAL AWR SNAPSHOT
#
########################################################

EXECUTE dbms_workload_repository.create_snapshot();

########################################################
#
# GENERATE AWR REPORT
#
########################################################

@$ORACLE_HOME/rdbms/admin/awrrpt.sql



########################################################
#
# FIND MVIEWS WHICH ARE CURRENTLY REFRESHING
#
########################################################

select o.owner, o.object_name mview, username, s.sid
from v$lock l, dba_objects o, v$session s
where o.object_id=l.id1 and
l.type='JI' and
l.lmode=6 and
s.sid=l.sid and
o.object_type='TABLE';

########################################################
#
# Configure SENDMAIL to send in different FONT
#
########################################################

if [ -s /home/oracle/bin/tab.out ]; then
(
echo "To: GlobalITOPS_DBSupport@spglobal.com"
echo "Subject: Warning: HIST-(nj09mhf0585): List of Tablespaces above threshold limit"
echo "MIME-Version: 1.0"
echo "Content-Type: text/html"
echo "<FONT FACE='COURIER NEW' SIZE='7'><PRE>"
cat /home/oracle/bin/tab.out
echo "</PRE></FONT>" ) | /usr/sbin/sendmail -t
fi

########################################################
#
# FIND CLUSTER NAME AND NODE COUNT
#
########################################################

$ sudo su - grid
$ $ORACLE_HOME/bin/cemutlo -n 

$ olsnodes -n

#########################################################
#
# SCAN_LISTENER: RELOCATE TO ANOTHER NODE
#
#########################################################

[nj09mhf0785.mhf.mhc:+ASM2:grid] srvctl relocate scan_listener -i 3 -n nj09mhf0785
[nj09mhf0785.mhf.mhc:+ASM2:grid] srvctl status scan
SCAN VIP scan1 is enabled
SCAN VIP scan1 is running on node nj09mhf0785
SCAN VIP scan2 is enabled
SCAN VIP scan2 is running on node nj09mhf0784
SCAN VIP scan3 is enabled
SCAN VIP scan3 is running on node nj09mhf0785
[nj09mhf0785.mhf.mhc:+ASM2:grid]

########################################################
#
# GOLDENGATE: TRACK ON GOING XID FROM DATABASE
#
########################################################

set lines 200 pages 1000
col xid for a16
col username for a18
col schemaname for a18
col osuser for a12
select s.inst_id, t.start_time, t.xidusn||'.'||t.xidslot||'.'||t.xidsqn xid, s.status,
s.sid,s.serial#,s.username,s.status,s.schemaname,
decode(s.sql_id,null,s.prev_sql_id) sqlid, decode(s.sql_child_number,null,s.prev_child_number) child
from gv$transaction t, gv$session s
where s.saddr = t.ses_addr
order by t.start_time;

########################################################
#
# Skip long running transaction in Goldengate
#
########################################################


WARNLONGTRANS 6H CHECKINTERVAL 1H SKIPEMPTYTRANS


## Add above parameter in Extract to skip empty transactions which are running for 6hours 

########################################################
#
# How to Overcome the Limitation 33 Columns per Supplemental Log Group (Doc ID 466439.1)
#
########################################################

Symptoms when trying to add trandata in Goldengate: 
2017-02-07 05:39:37  WARNING OGG-00706  Failed to add supplemental log group on table SFI.ABS_COLLAT_PERF due to ORA-02257: maximum number of columns exceeded

Symptoms when trying to add supplemental logging in Oracle database: 
ORA-02257: maximum number of columns exceeded

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

According to unpublished bug 2376027 there is a strictly enforced limit of 33 columns per supplemental log group.

If more than 33 are required then additional supplemental log groups for the same table need to be specified until the number of required supplementally logged groups is reached.  It is not necessary that all the columns belong to the same supplemental log group. This will ensure that all the necessary information is place in the redo stream.

So in the case of a table with more than 33 columns  you create as many distinct supplemental log groups as required for the same table, e.g.,

ALTER TABLE <table_name> ADD SUPPLEMENTAL LOG GROUP <log_grp1>
(Column1,....,Column33) ALWAYS;

ALTER TABLE <table_name> ADD SUPPLEMENTAL LOG GROUP <log_grp2>
(Column34,....,Column66) ALWAYS;

ALTER TABLE <table_name> ADD SUPPLEMENTAL LOG GROUP <log_grp3>
(Column67,....,Column99) ALWAYS;

...
.

If you attempt to create a supplemental log group with more than 33 columns in it an ORA-02257 will be reported.
 

    /                                                                        /****************************************************************************/
    /                                                                        /****************************************************************************/
    /                                                                        /****************************************************************************/
    /                                                                        
    /                                                                        		.__.       .________. .__ .   .__. .__.   .__. .___.    .___.
    /                                                                        		|  |       |__    __| |   \   |  | |  |   |  |  \  \    /  /
    /                                                                        		|  |          |  |    |    \  |  | |  |   |  |   \  \  /  /
    /                                                                        		|  |          |  |    |  |\ \ |  | |  |   |  |    \  --  /  
    /                                                                        		|  |          |  |    |  | \ \|  | |  |   |  |    /  --  \
    /                                                                        		|  |_____. .__|  |__. |  |  \ |  | |  |___|  |   /  /  \  \
    /                                                                        		|________| |________| |__|   \___| |_________|  /__/    \__\
    /                                                                        
    /                                                                        /****************************************************************************/
    /                                                                        /****************************************************************************/
    /                                                                        /****************************************************************************/

##########################################
#
# FIND LARGEST DIRECTORIES IN LINUX
#
##########################################

du -hs * | sort -rh | head -5

To display the largest folders/files including the sub-directories, run:

du -Sh *| sort -rh | head -5

##########################################
#
# STRACE SQLPLUS QUERY OUTPUT
#
##########################################

for count in {1..10}
do
strace -o /home/oradb/oracle_acs/strace_output_${count}.txt sqlplus -s / as sysdba @/home/oradb/oracle_acs/status_test.sql > /home/oradb/oracle_acs/sqlplus_output_${count}.txt
done

##########################################
#
# Delete Files Older Than x Days on Linux
#
##########################################

find /home/oracle/dbfs_trace/*.gz -mtime +90 -exec rm {} \;

##########################################
#
# BETTER WAY TO FIND $PATH OUTPUT
#
##########################################

echo $PATH | tr ':' '\n'


#########################################################################################################

##########################################
#
# Mapping ASM disks to Physical Devices
#
##########################################

#!/bin/ksh
for i in `/etc/init.d/oracleasm listdisks`
do
v_asmdisk=`/etc/init.d/oracleasm querydisk $i | awk  '{print $2}'`
v_minor=`/etc/init.d/oracleasm querydisk -d $i | awk -F[ '{print $2}'| awk -F] '{print $1}' | awk -F, '{print $1}'`
v_major=`/etc/init.d/oracleasm querydisk -d $i | awk -F[ '{print $2}'| awk -F] '{print $1}' | awk -F, '{print $2}'`
v_device=`ls -la /dev | grep ${v_minor} | grep ${v_major} | awk '{print $10}'`
echo "ASM disk $v_asmdisk based on /dev/$v_device  [$v_minor $v_major]"
done

##########################################
#
# SHELL: Run local script remotely
#
##########################################

ssh 172.17.85.165 "ps -ef |grep pmon|grep -v grep|/bin/awk -F _ '{print \$3}'"
ssh 172.17.85.165 "ps -ef |grep pmon|grep -v grep|awk -F _ '{print \$3}'|tail -n1"


for x1 in `grep -v '^#' host.out.nks`
do
ssh $x1 "bash -s" < ./nks_1.bsh >>nks_3.out
done



#########################################
#                                       #
# Name   : asmdu.bsh         	        #
# Purpose: Find disk usage of ASM       #
#          directories                  #
# Usage  : Before executing this script #
#		   								#
#		   ./asmdu.bsh DIRECTORY_NAME   #
#										#
#########################################
#!/bin/bash
#
# du of each subdirectory in a directory for ASM
#
D=$1

if [[ -z $D ]]
then
 echo "Please provide a directory !"
 exit 1
fi

(for DIR in `asmcmd ls ${D}`
 do
echo ${DIR} `asmcmd du ${D}/${DIR} | tail -1`
 done) | awk -v D="$D" ' BEGIN {  printf("\n\t\t%40s\n\n", D " subdirectories size")           ;
                 printf("%25s%16s%16s\n", "Subdir", "Used MB", "Mirror MB")   ;
                 printf("%25s%16s%16s\n", "------", "-------", "---------")   ;}
                 {
                 printf("%25s%16s%16s\n", $1, $2, $3)                         ;
                 use += $2                                                    ;
                 mir += $3                                                    ;
                 }
                 END   { printf("\n\n%25s%16s%16s\n", "------", "-------", "---------");
                 printf("%25s%16s%16s\n\n", "Total", use, mir)                 ;} '


##########################################################################
##
## Use below settings to ensure SQLPLUS is generating HTML format output
##
##########################################################################

SET MARKUP HTML ON SPOOL ON HEAD "<TITLE> INFO </title> - <STYLE TYPE='TEXT/CSS'><!--BODY {background: ffffc6} --></STYLE>" 
SET ECHO ON 
spool 3-14248770960.html 

##############################################################################################################################################################
#!/bin/ksh
#########################################
#                                       #
# Name: countninsert.ksh                #                                             
# Purpose: Find count of rows from      #
#          table and insert into        #
#		   another table                #
#########################################

. /home/oracle/scripts/ora_env.sh

for t_name in T1_RPT_STRGY_TXPCY_CTD_STG T1_RPT_CTD_TXPCY T1_RPT_CTD_TXPCY_OLD
do
sqlplus -S / as sysdba << !
set serveroutput on
declare
t_count number;
TABLE_NOT_FOUND EXCEPTION;
PRAGMA EXCEPTION_INIT(TABLE_NOT_FOUND, -942);
BEGIN
EXECUTE IMMEDIATE 'SELECT count(*) FROM mt_rpt01.${t_name}' into t_count;
insert into dbmon.table_count (table_name, table_count) values ('${t_name}',t_count);
commit;
EXCEPTION
WHEN TABLE_NOT_FOUND
THEN
t_count := 0;
insert into dbmon.table_count (table_name, table_count) values ('${t_name}',t_count);
commit;
END;
/
exit
!
done

====================================================================


#!/usr/bin/bash
#########################################
#                                       #
# Name: dbname.bsh                      #                                             
# Purpose: Script to find Database Name #
#########################################
clear
dbn=`sqlplus -s / as sysdba << !
set heading off pages 0
select name from v\\$database;
exit;
!
`
echo
echo "Current Database Name: ${dbn}"
echo



====================================================================

#!/usr/bin/bash
###########################################################
#                                                         #
# Name: get_inv_location.bsh                              #
# Purpose: Script to determine oracle inventory location  #
#                                                         #
###########################################################

loc=`cat /etc/oraInst.loc | grep -v "#" | grep inventory_loc | awk -F= '{print $2}'`
echo
echo Oracle Inventory Location: ${loc}
echo


====================================================================

#!/usr/bin/bash
###########################################################
#                                                         #
# Name: details.bsh                                       #
# Purpose: find multiple queries using various arguments  #
#                                                         #
###########################################################

if [ $# -eq 0 ] ; then
echo
echo "Select from the list of queries, to execute: "
echo
ls *.sql | grep -v slogin.sql
echo
echo -n "Enter Script name: " ; read arg
echo
sqlplus -s / as sysdba << !
@${arg}
exit;
!
exit 0
else
arg=$1
sqlplus -s / as sysdba << !
@${arg}
exit;
!
fi

====================================================================
date format
﻿date +%m/%d/%y_%k:%M:%S


#!/bin/ksh
#
####################################################
# Name            : rman_chg_config.scr
# Created by      : Sourav Biswas
# Date            : Oct 24th, 2014
# Description	  : Script will reset SBT TAPE
#		    		settings for RMAN and configure
#	            	DISK settings
####################################################
# 
# LIST OF DATABASE

for i in `cat /etc/oratab | grep -v "#" | awk -F : '{if ($3=="Y") print $1}'` ## THIS WILL ENSURE SHUTDOWN DATABASES ARE ALSO INCLUDED

do

# SETTING DATABASE ENVIRONMENT

. /usr/oracle/go_${i}

# CREATING ORABACK DESTINATION FOR DATABASE

mkdir -p /oraback/humpback/${i}

# SCRIPT TO CHANGE RMAN PARAMETERS

echo "connect target /"                                                                              > /usr/oracle/sourav/rconfig.rman
echo "CONFIGURE DEVICE TYPE 'SBT_TAPE' clear;"                                                      >> /usr/oracle/sourav/rconfig.rman
echo "CONFIGURE RETENTION POLICY TO RECOVERY WINDOW OF 31 DAYS;"                                    >> /usr/oracle/sourav/rconfig.rman
echo "CONFIGURE CONTROLFILE AUTOBACKUP ON;"                                                         >> /usr/oracle/sourav/rconfig.rman
echo "CONFIGURE CONTROLFILE AUTOBACKUP FORMAT FOR DEVICE TYPE DISK TO '/oraback/humpback/${i}/%F';" >> /usr/oracle/sourav/rconfig.rman
echo "CONFIGURE DEVICE TYPE DISK PARALLELISM 3 BACKUP TYPE TO BACKUPSET;"                           >> /usr/oracle/sourav/rconfig.rman
echo "CONFIGURE CHANNEL DEVICE TYPE DISK FORMAT '/oraback/humpback/${i}/%U';"                       >> /usr/oracle/sourav/rconfig.rman
echo "exit;"                                                                                        >> /usr/oracle/sourav/rconfig.rman

# LOGFILE FOR RCONFIG.RMAN
echo "***************************************************************************"  >> /usr/oracle/sourav/rconfig.log
echo "***********************Configuring RMAN for ${i}***********************"      >> /usr/oracle/sourav/rconfig.log
echo "***************************************************************************"  >> /usr/oracle/sourav/rconfig.log
echo										    >> /usr/oracle/sourav/rconfig.log

# CHANGING RMAN PARAMETERS

rman @/usr/oracle/sourav/rconfig.rman >> /usr/oracle/sourav/rconfig.log

echo                                                                            >> /usr/oracle/sourav/rconfig.log

# SCRIPT TO CAPTURE ALL PARAMETER

echo "connect target /"          > /usr/oracle/sourav/showall.rman
echo "show all;"                >> /usr/oracle/sourav/showall.rman
echo "exit;"                    >> /usr/oracle/sourav/showall.rman

# LOGFILE FOR SHOWALL.RMAN
echo "***************************************************************************"  >> /usr/oracle/sourav/showall.log
echo "***********************Configuring RMAN for ${i}***********************"      >> /usr/oracle/sourav/showall.log
echo "***************************************************************************"  >> /usr/oracle/sourav/showall.log
echo										    >> /usr/oracle/sourav/showall.log

# CAPTURE LIST OF PARAMETERS FOR INDIVIDUAL DATABASE

rman @/usr/oracle/sourav/showall.rman >> /usr/oracle/sourav/showall.log

echo										    >> /usr/oracle/sourav/showall.log

done
exit

====================================================================

#!/bin/ksh
#
###############################################################################
#
# Created by      : Sourav Biswas
# Date            : Oct 9th, 2014
# Description     : Daily_ORAGHGP1_Export.ksh was written to automate ORAGHGP1
#                   database export every day at 10PM MST. This job emails a
#                   copy of logfile to Jagadish Maddiboyina. Also the job
#                   deletes dump files older than 3 days.
#
###############################################################################
###############################################################################
# Define script variables
###############################################################################
ORACLE_SID=oraghgp1;export ORACLE_SID
EXP_DIR=/oradba/exports/$ORACLE_SID/Do_Not_Delete; export EXP_DIR
PARFILE=$EXP_DIR/${ORACLE_SID}_exp.par; export PARFILE
LOGFILE=full_db_exp_${ORACLE_SID}_`date "+%b-%d_%T"`.log; export LOGFILE
STAT_LOG=${EXP_DIR}/Daily_ORAGHGP1_Export_`date "+%Y%m%d"`.log; export STAT_LOG
###############################################################################
# CHECK TO SEE IF go_(SID) script exists to make sure we're running this
# against a local instance of Oracle.
###############################################################################
if (test -f $HOME/go_${ORACLE_SID})
   then
     echo `date` > ${STAT_LOG}
     echo "File: go_${ORACLE_SID} exists. Exporting schema ${SCM} from local database ${ORACLE_SID}" >> ${STAT_LOG}
     echo >> ${STAT_LOG}
     echo '*****************************************************************************' >> ${STAT_LOG}
   else
     echo `date` > ${STAT_LOG}
     echo "File: go_${ORACLE_SID} does not exist, make sure ${ORACLE_SID} is a local database" >> ${STAT_LOG}
     echo "CANCELLING export job" >> ${STAT_LOG}
     echo >> ${STAT_LOG}
     echo '*****************************************************************************' >> ${STAT_LOG}
     exit
fi
###############################################################################
# REMOVE OLD DUMPFILES AND LOGFILES
###############################################################################
find ${EXP_DIR} -type f -mtime +4 -name "*.dmp" -exec rm {} \; 2> /dev/null
find ${EXP_DIR} -type f -mtime +4 -name "*.log" -exec rm {} \; 2> /dev/null
echo >> ${STAT_LOG}
echo removed previous dump files & log files >> ${STAT_LOG}
echo >> ${STAT_LOG}
echo "*****************************************************************************" >> ${STAT_LOG}
echo >> ${STAT_LOG}
#################################################################################
# BUILD THE IMPORT PARFILE
#################################################################################
echo userid=\'/ as sysdba\'					                           > $PARFILE
echo job_name=exp_${ORACLE_SID}                                       >> $PARFILE
echo logfile=DP2:${LOGFILE}					                          >> $PARFILE
echo directory=DP2						                              >> $PARFILE
echo dumpfile=DP2:full_db_exp_${ORACLE_SID}_`date "+%b-%d_%T"`_%U.dmp >> $PARFILE
echo parallel=4                                                       >> $PARFILE
echo full=y                                                           >> $PARFILE

chmod 700 $PARFILE

echo "Parfile Created with required details" >> ${STAT_LOG}
#################################################################################
# SET THE ORACLE ENVIRONMENT VARIABLES
#################################################################################
. $HOME/go_${ORACLE_SID}
cd $EXP_DIR
#################################################################################
# EXPORT FULL DATABASE BACKUP
#################################################################################
cd $EXP_DIR
echo >> ${STAT_LOG}
echo "************* EXPORT BEGINS ON `date` *************" >> ${STAT_LOG}
expdp parfile=$PARFILE
#################################################################################
# MAILING RESULTING LOG FILE TO JAGADISH MADDIBOYINA
#################################################################################

echo >> ${STAT_LOG}
echo "*****************************************************************************" >> ${STAT_LOG}
echo "${ORACLE_SID}: Full database has being exported. Please check ${LOGFILE} logfile for export status" >> ${STAT_LOG}
echo >> ${STAT_LOG}
echo "Emailed copy of logfile to Jagadish.C.Maddiboyina@contractor.conocophillips.com" >> ${STAT_LOG}

mailx -s "Export log for full database ${ORACLE_SID} backup" Jagadish.C.Maddiboyina@contractor.conocophillips.com << !
Hi Jagadish,

Please find below full export log for ${ORACLE_SID} database. This is an automated email.

******************************************************************************************

`cat ${LOGFILE}`

******************************************************************************************
!

====================================================================

########################################################################################
#
# OEM Alert: Metric evaluation error start - Compute dynamic property takes too long
#
########################################################################################

./emctl reload agent dynamicproperties -upload_timeout 240 LISTENER_SCAN1_co01mhf0029clus:oracle_listener

########################################################################################
#
# VI Editor: Delete empty lines
#
########################################################################################

:g/^$/d

########################################################################################
#
# VI Editor: Delete spaces from end of line -- There is a space before "*"
#
########################################################################################

:%s/ *$//

########################################################################################
#
# UNIX: CASE-INSENSITIVE SEARCH USING "LS" COMMAND
#
########################################################################################
$ shopt -s nocaseglob

You may add this to .bashrc or .bash_profile as well
